<html>
<head>
<style type="text/css">
hr.normal { color:#ddd; background-color:#ddd; height:5px; }
hr { color:#000; background-color:#000; height:1px; }
h3 { below-border-color:#000; height:5px; }
pre {
white-space: pre-wrap; /* css-3 */
white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */
white-space: -pre-wrap; /* Opera 4-6 */
white-space: -o-pre-wrap; /* Opera 7 */
word-wrap: break-word; /* Internet Explorer 5.5+ */
}
</style>

<title>
Pelib: Programming Environment Library - Documentation and Examples
</title>

<script type="text/javascript" src="http://www.ida.liu.se/labs/pelab/skepu/syntaxHigh/syntaxhighlighter_3.0.83/scripts/shCore.js"></script> 
<script type="text/javascript" src="http://www.ida.liu.se/labs/pelab/skepu/syntaxHigh/syntaxhighlighter_3.0.83/scripts/shBrushCpp.js"></script> 
<link type="text/css" rel="stylesheet" href="http://www.ida.liu.se/labs/pelab/skepu/syntaxHigh/syntaxhighlighter_3.0.83/styles/shCoreDefault.css"/> 

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37057723-1']);
  _gaq.push(['_setDomainName', 'ida.liu.se']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>

<body bgcolor=#FFFFFF>

<center>
<h1>
<font color=#000000>
Pelib: Programming Environment Library
</font>
</h1>
<h2>
<font color=#000000>
Documentation and Examples
</font>
</h2>
</center>

<p>
</p>

<p>
</p>

<center>
<font face=arial,helvetica size=0 color=#000000>
<table border="1" bordercolor="#101010" bgcolor="#fffff0" cellpadding="3">
<tr>
<td><a href="http://www.ida.liu.se/labs/pelab/pelib/index.html#overview">Overview</a> </td>
<td><a href="http://www.ida.liu.se/labs/pelab/pelib/index.html#publications">Publications</a> </td>
<td><a href="http://www.ida.liu.se/labs/pelab/pelib/index.html#example">Code Examples</a> </td>
<td><a href="http://www.ida.liu.se/labs/pelab/pelib/index.html#download">Download</a> </td>
<td><a href="http://www.ida.liu.se/labs/pelab/pelib/index.html#license">License</a> </td>
<td><a href="http://www.ida.liu.se/labs/pelab/pelib/index.html#ongoing">Ongoing Work</a> </td>
<td><a href="http://www.ida.liu.se/labs/pelab/pelib/index.html#contact">Contact</a> </td>
<td><a href="http://www.ida.liu.se/labs/pelab/pelib/index.html#funding">Acknowledgments</a> </td>
</tr>
</table>
</font>
</center>

<p>
</p>

<font face=arial,helvetica size=-1 color=#000000>

<p>
Pelib stands for <b>P</b>rogramming <b>E</b>nvironment <b>Lib</b>rary, as the reference to PELAB (<b>P</b>rogramming <b>E</b>nvironment <b>Lab</b>oratory).
It is a swiss army knife for various research activity, in particular around on-chip pipelining and scheduling research.
The pelib includes a flexible C++ programming interface to read and write simple and complex data structure in various text format such as AMPL input data, AMPL output results, GraphML-based streaming applications models and XML-based schedule descriptions. The capability to parse and generate AMPL input and output data simplifies considerably the automation of experimental performance comparison between Linear Programming solvers and C++ algorithm implementations. A C++ program can generate AMPL input problem instances to feed a linear solver with a AMPL frontend and parse its output to compare with another solving method, such as a C++ implementation of a heuristic. We use this approach in our previous and future <a href="#publications">research papers</a>.
The pelib also provides convenient generic C data structures with type checking, based on an object-oriented design, providing fast ways to show the precise state of internal data structures and functionality composition.
These data structures are extensively used used in the <a href="/labs/pelab/drake/index.html">Drake</a> C stream programming framework.
<br>This pages reviews the main features describes above, how to use and extend them. Section <a href="#overview">overview</a> gives a brief overview of pelib. Section <a href="#download">download</a> provides downloading link to the latest pelib source package. Section <a href="#licence">licence</a> provides information about our publication licence. Section <a href="#publications">publication</a> gives the list of articles we published using this library. Section <a href="#installation">installation</a> provides some explanations to compile and install the library. Section <a href="#parsing">Parsing and generating text representation of complex data structures</a> gives code examples on how to use the parser and output classes provded by pelib and describe the underlying structure to respect when writing new parser and output classes. Section <a href="#c_data_structure">Generic C data structures</a> gives an extended description of the C data structures implemented, how to extend their functionalities as well as adding new generic data structures. Check also the <a href="doxygen/html/index.html">doxygen documentation</a> for more detailed information.
</p>

<hr>

<h2 id="overview">Overview</h2>
</a>

<p>
Main features:
<ul>
<li>Parsing and generation of AMPL input data files composed of scalars, vectors, sets or matrices of arbitrary types
<li>Parsing and generation of AMPL output results composed of scalars, vectors, sets or matrices of arbitrary types
<li>Parsing and generation of GraphML-based stream application (taskgraph) descriptions
<li>Parsing and generation of AMPL-based execution platform descriptions
<li>Parsing and generation of streaming application schedules in XML format
<li>Conversion between AMPL input and AMPL output format of algebraic data structures (scalar, vector, set or matrix)
<li>Conversion between GraphML taskgraphs or XML schedules and AMPL input or output data format
<li>API designed for easy maintainability and high extention opportunities
</ul>

<p>
</p>


<hr>
<p>
<br>
</p>

<h2 id="download">Download</h2>
</a>

<p>
<a href="https://www.ida.liu.se/labs/pelab/pelib/download/pelib-1.0.0.tar.gz" onclick="var that=this;_gaq.push(['_trackEvent','Download','Pelib',this.href]);setTimeout(function(){location.href=that.href;},200);return false;">
<b>Download source code</b></a>
</p>
<p>
<!--
See also the <a href="http://www.ida.liu.se/labs/pelab/pelib/doc_0.8/html/"><b>html documentation</b></a> generated by doxygen.
 -->
</p>
</li>
</ol>

<hr>
<p>
<br>
</p>


<h2 id="license"> Software License </h2>
</a>

<p>
The source code available above is released under GPLv3 licence. Please contact Nicolas Melot (nicolas.melot@liu.se) if you want to obtain another licence.
</p>

<hr>
<p>
<br>
</p>

<h2 id="publications">
Publications 
</h2>
</a>
This library is heavily used internally by Crown scheduling heuristic C++ implementations, C++ schedule analytic evaluators used in our Crown Scheduler paper as well as in the <a href="/labs/pelab/drake/index.html">Drake</a> C stream programming framework. Below is a list of papers whose experimental work relied on the pelib library.
<ul>
<li><p>
Nicolas Melot, Christoph Kessler, Joerg Keller and Patrick Eitschberger
<b>Fast Crown Scheduling Heuristics for Energy-Efficient Mapping and Scaling of Moldable Streaming Tasks on Many-Core Systems.</b>
ACM Transaction on Architecture and Code Optimization, ACM, 2015
</p></li>
<li><p>
Nicolas Melot, Johan Janzen, Christoph Kessler:
<b>Mimer and Schedeval: Comparison Tools for Static Schedulers and Streaming Applications on Concrete Manycore Architectures.</b>
Eighth International Workshop on Parallel Programming Models and Systems Software for High-End Computing (P2S2) at ICPP, 2015. IEEE. 
</p></li>
</ul>


<hr>
<p>
<br>
</p>

<h2 id="installation">Installation</h2>
<p>
Pelib requires the libraries igraph (&gt;= 0.7.1), libdl, libboost-regex, libboost-graph and libexpat, pthread and libxml++-2.6 to compile and run correctly. Once the dependencies are installed, define the environment variables CC=gcc (or any other C compiler you prefer, provided its switches are the same as gcc) and CXX=g++. <a href="download/pelib-1.0.0.tar.gz">Download</a> and extract the pelib source package. cd' into the pelib source directory, make sure you use GNU make and type 
<pre class="brush: cpp">
make install
</pre>
to compile and install the pelib. This will install pelib libraries in $HOME/.local/lib, pelib include files in $HOME/.local/include and pkg-config file in $HOME/.local/lib/pkgconfig. If you wish to install it elsewhere, type
<pre class="brush: cpp">
make install prefix=&lt;/any/path/at/all&gt;
</pre>
Make will create directories bin, lib, lib/pkgconfig and include in the the installation directory you may choose.
</p>

<hr>
<p>
<br>
</p>

<h2 id="parsing">Parsing and generating text representation of complex data structures</h2>
</a>

<p>
This section gives examples on pelib's functionalities to parse complex data structures. Section <a href="#parsing_use">General usage</a> gives example on how to use parser and output classes provided by the pelib. Section <a href="parsing_extend">Contributing</a> gives general indication on how to write your own parser or output class that integrates in pelib.

<h3 id="parsing_use">General usage</h3>
This section gives general usage of the pelib parsing and output framework as well as the conversion command line tool pelib-convert.

<h4 id="parsing_use_framework">Pelib parsing and output framework</h4>
We suppose in this example that we want to load the value of p written in the AMPL input data file "parse-example-1.dat" as follows:
<pre class="brush: cpp">
param p := 3.141592653;
</pre>
The code snippet below uses the AMPL input data parser to reads the input file "example.dat" and outputs the value of scalar "p" to standard output.
<pre class="brush: cpp">
#include &lt;pelib/AmplInput.hpp&gt;

using namespace std;
using namespace pelib;

int
main(int argc, char** argv)
{
	// Variables declaration
        ifstream input; // File input stream
        AmplInput parser(AmplInput::intFloatHandlers()); // AMPL input data parser class with integer and float input parsers and output
        Algebra container; // Collection of Algebraic data structures
        const Scalar&lt;float&gt; *scalar_p; // A scalar
        float p; // Final variable that receives the value parsed

	// Open the file, use AmplInput to parse it into an Algebra container and close the file
        input.open("parse-example-1-data.dat");
        container = parser.parse(input);
        input.close();

	// Find and return the floating-point scalar value named "p" in the algebra container
        scalar_p = container.find&lt;Scalar&lt;float&gt; &gt;("p");

	// Read scalr p's value into float variable p
        p = scalar_p-&gt;getValue();

	// Output p
        cout &lt;&lt; "p = " &tl;&lt; p &lt;&lt; endl;

        return 0;
}
</pre>
You can build this example with the command line
<pre class="brush: cpp">
g++ example-parse-1.cpp `pkg-config --cflags --libs pelib` -o parse-example-1
</pre>
Make sure the file parse-example-1.dat is available in the active directory and contains the text above, then simply type
<pre class="brush: cpp">
./parser-example-1
</pre>
</p>
<p>
Suppose now that we want to generate some AMPL output text format from a array of integers. The code snippet below performs this task:
<pre class="brush: cpp">
#include &lt;pelib/AmplOutput.hpp&gt;
#include &lt;pelib/Vector.hpp&gt;

using namespace std;
using namespace pelib;

int
main(int argc, char** argv)
{
        // Variables declaration
        float F[4] = {1, 2.71, 3.14, 42};
        map&lt;int, float&gt; map_f;

        // Fills a map of values and their keys
        for(size_t i = 0; i &lt; 4; i++)
        {
                map_f.insert(pair&lt;int, float&gt;((int)i + 1, F[i]));
        }

        // Builds a vector named "F" with values in map_f
        Vector&lt;int, float&gt; vector_f("F", map_f);

        // Output vector_f to standard output
        AmplOutput(AmplOutput::intFloatHandlers()).dump(cout, vector_f);

        return 0;
}
</pre>
</p>
<p>
Suppose finally, that we want to convert an AMPL input data file into AMPL output format:
<pre class="brush: cpp">
#include &lt;pelib/AmplInput.hpp&gt;
#include &lt;pelib/AmplOutput.hpp&gt;

using namespace std;
using namespace pelib;

int
main(int argc, char** argv)
{       
        ifstream input;
        Algebra container;
        const Scalar&lt;float&gt; *scalar_p;
        float p;
        
        input.open("example.dat");
        container = AmplInput(AmplInput::intFloatHandlers()).parse(input);
        input.close();

        AmplOutput(AmplOutput::intFloatHandlers()).dump(cout, container);

        return 0;
}
</pre>
</p>

<p>
Parsers and output are also available for more complex data structures, such as streaming application descriptions (taskgraphs) and schedules. Just as Algebraic data structures have Algebra containers, taskgraphs, platform and schedule have their own container classes. Taskgraph and Schedule containers are instanciated by dedicated parsers classes (GraphML and XMLScehdule are available now, respectively for taskgraph and Schedules) and can be output by some output classes (GraphML and XMLSchedule can also output taskgraphs and schedules, respectively) in the exact same manner as shown above. Platform description have no format of its own yet, and is instead read as an algebraic container that is used to instanciate an instance of Platform. Taskgraph, Schedule and Platform classes can all be instanciated from an algebraic description of their respective data structure. Also, they can all build an Algebra container that holds all information about themselves. See the <a href="doxygen/html/index.html">doxygen documentation</a> to get more information about this feature.
</p>

<p>
Here is a list of classes able to parse and output data structures:
<ul>
<li>AmplInput (#include &lt;pelib/AmplInput.hpp&gt;): Parses and output Algebraic data in AMPL input data format
<li>AmplOutput (#include &lt;pelib/AmplOutput.hpp&gt;): Parses and output Algebraic data in AMPL output results format
<li>Cpp (#include &lt;pelib/Cpp.hpp&gt;): Generates C++ code that instanciates pelib algebraic data structures
<li>GraphML (#include &lt;pelib/GraphML.hpp&gt;): Parses and output streaming application high-level descriptions in format based on GraphML
<li>XMLSchedule (#include &lt;pelib/XMLSchedule.hpp&gt;): Parses and output streaming application schedules in XML format
</ul>
</p>

<h4 id="parsing_use_conversion">Pelib conversion tool</h4>

<p>
This section provides a manual to the pelib flexible command line file format conversion tool <b>pelib-convert</b>. pelib-convert can read one or several input stream in any format pelib can parse and output it in any format pelib can output. It uses dynamic libraries to handle input and output streams so that any conversion scenario can be performed without having been explicitely programmed. Here is the syntax of pelib-convert
<pre class="brush: cpp">
pelib-convert (--input ( --format &lt;format&gt; | --lib &lt;library&gt; ) ( --stdin | --file /path/to/input/file ) [ --args &lt;arguments&gt; [ -- ] ] [ --name &lt;name&gt; ] )* (--output ( --format &lt;format&gt; | --lib &lt;library&gt; ) ( --stdout | --stderr | --file /path/to/output/file ) [ --name &lt;name&gt; ] [ --args &lt;arguments&gt; [ -- ] ] )*
</pre>
<b>&lt;format&gt;</b> takes shape as &lt;structure&gt;-&lt;syntax&gt; where &lt;structure&gt; is a complex data structure such as <b>taskgraph</b>, <b>schedule</b> or <b>platform</b> and &lt;syntax&gt; is its text format, such as <b>graphml</b> or <b>xml</b> as well as <b>ampl_input</b> or <b>ampl_output</b>. For algebraic data to parse or output, &lt;structure&gt; must be omitted and &lt;syntax&gt; is one of <b>ampl_input</b> or <b>ampl_output</b>. 
<br><b>&lt;library&gt;</b> denotes the filename of a dynamic library (typically ending with .so) that contains the code to parse or output data in some format. If a path (absolute or relative) is not given, then pelib-convert searches for the library in folders defined by the environment variable LD_RUN_PATH as it was set when pelib-convert was linked, or in LD_LIBRARY_PATH, if defined. "--format &lt;format&gt;" is actually a shortcut for "--lib libpelib-&lt;format&gt;.so"
is any sequence of strings, separated by one or several spaces or tabs. Arguments can be grouped using quote or double quotes or anything your shell provide to pass arguments with space characters. Arguments passed to the parsing or output library stop at the first occurrence of the string "--" or when the last command line argument is read.
<br><b>&lt;arguments&gt;</b> is any sequence of strings, separated by one or several spaces or tabs. Arguments can be grouped using quote or double quotes or anything your shell provide to pass arguments with space characters. Arguments passed to the parsing or output library stop at the first occurrence of the string "--" or when the last command line argument is read. "--" is mandatory if more arguments for pelib-convert follow. libtaskgraph-streamit takes one optional argument to name the taskgraph being parsed. None of the other libraries among ampl_*, taskgraph-*, schedule-* or platform-* require any argument.
<br><b>&lt;name&gt;</b> gives a id to identify an input data source so that several input of the same type (taskgraph, schedule or platform) can be given in a single command line. Some output library may require two instances of the same time. In this case, it needs to differenciate what input serves for a particular purpose. Refer the manual of the output library you use for more information. None of the output libraries ampl_*, taskgraph-*, schedule-* or platform-* require any such name.
</p>

<p>As an example, the command line below is equivalent to the last example given in Section <a href="#parsing_use_framework">pelib parsing and output framework</a>:
<pre class="brush: cpp">
pelib-convert --input --format ampl_input --file example.dat --output --format ampl_output --stdout
</pre>
</p>

<h3 id="parsing_extend">Contributing</h3>
<p>
This section gives insights on the general structure of pelib parsers and output classes so that contributions can preserve its highly flexible feature. Section <a href="#parsing_extend_framework">Extending pelib framework</a> discusses the general structure of the pelib C++ framework and Section <a href="#parsing_extend_convert">Extend pelib-convert features</a> discusses the structure of a pelib-convert parsing and output plugin.
</p>

<h4 id="parsing_extend">Extending pelib framework</h4>
<p>
Every parser and output classes in pelib store or read the data they parse or output in intermediate, format-agnostic data structure classes. These include Algebra, Taskgraph, Platform and Schedule. They serve as an independant pivot point when conversion between formats need to be performed, or as data to feed C++ algorithm implementation with or that C++ algorithm implementations produce. This is a central concept crucial to the flexibility of pelib framework.
<br>Every data structure pelib can handle is a descendant of class pelib::Data or pelib::Record. Descendant classes of pelib::Data represent simple data structures that can be grouped in a collection that derives from pelib::Record. In contrast, pelib::Record classes represent complex data structures. In particular, any algebraic data structure (scalar, vector, set or matrix) derives from pelib::AlgebraData that is itself a descendant of pelib::Data, whereas classes Taskgraph, Platform and Schedule are complex data structures that derive from pelib::Record. All Algebraic data structures (that descend from pelib::AlgebraData) can be included in a algebraic data container (pelib::Algebra) that is considered as a complex data structure and derives from pelib::Record.
</p>
<p>
Parser and an output classes for simple data structures derives from pelib::DataParser and pelib::DataOutput, respectively, or both. More specifically, Algebraic data structure parser and output classes derive from pelib::AlgebraDataParser and pelib::AlgebraDataOutput, respectively, or both. In contrast, parsers and output classes descend from pelib::RecordParser or pelib::RecordOutput, respectively, or both. Again, an algebraic data structure collection parser or output derive from pelib::AlgebraParser or pelib::Algebra parser, that respectively derive from pelib::RecordParser and pelib::RecordOutput. Parser and output classes for Taskgraph, Platform and Schedule also derive from pelib::RecordParser and pelib::RecordOutput (or again, from both). Each simple or complex parser or output class derive from pelib::DataParser or pelib::RecordParser, or their output counterpart, to classes that specialize into different text formats, for instance pelib::GraphMLParser or pelib::AmplInputParser. Finally, parser and output classes specialized for a given format are merged into a single parsing and output class, such as pelib::GraphML or pelib::AmplInput.
</p>
<p>
Parser and output classes of complex data structure composed as several simple data structures (such as pelib::Algebra) are composed of several parsers of simple data structures. For example, pelib::AmplInput parses simple data structure such as pelib::Scalar, pelib::Vector, pelib::Set and pelib::Matrix using pelib::AmplInputScalar (see <a href="doxygen/html/classpelib_1_1_ampl_input_scalar.html">doxygen documentation</a> for a detailed view of its inheritance diagram), pelib::AmplInputVector, pelib::AmplInputSet and pelib::AmplInputMatrix. These classes can also generate outputs in AmplInput formats because they inherit from <a href="doxygen/html/classpelib_1_1_ampl_input_data_output.html">pelib::AmplInputDataOutput</a>. 
</p>
<p>There are several possible scenarii to extend pelib with new parser or output.
<ul>
<li>The implementation of a new parser or output class for a complex data structure that already exists. Such a class needs to inherit from the class that defines a parser or an output class of this complex data structure. For instance, let us call <b>NTGF</b> (for <b>N</b>ew <b>T</b>ask<b>G</b>raph <b>F</b>ormat) a new text format for taskgraphs. In order to implement a new NTGF Taskgraph parser and output, we need to create a class that derives from <a href="doxygen/html/classpelib_1_1_taskgraph_parser.html">pelib::TaskgraphParser</a> and another that derives from <a href="doxygen/html/classpelib_1_1_taskgraph_output.html">TaskgraphOutput</a>. Let us call them <b>NTGFParser</b> and <b>NTGFOutput</b>, respectively. Finally, we can create a new class that combines both the parser and output classes together for convenience. Let us call this final class <b>NTGF</b>.</li>
<li>Implmenting a new complex data structure and its parser and output class. Let us add the complex data structure <b>Car</b>. We need to create a new class <b>Car</b> that derives from the complex data structure ancestor class pelib::Record. Then we need to create classes <b>CarParser</b> and <b>CarOutout</b> so we have common base parser and output classes for any other later parser and output classes for our new complex data structure Car. The we can add the first parsing and output classes using the same procedure as described in the previous bullet</li>
<li>Adding a new simple algebraic data structure beside Scalar or Vector. Let us add the simple data structure for (ironically) complex numbers. We need a new class <b>complex</b> to derive from AlgebraData. We need to implement additional parser and output classes for all syntaxes alread defined for Algebra, that is in the present state of pelib, <a href="doxygen/html/classpelib_1_1_ampl_input_data.html">AmplInputData</a> and <a href="doxygen/html/classpelib_1_1_ampl_output_data.html">AmplOutputData</a>. Let us call these two additional parsing and output classes <b>AmplInputComplex</b> and <b>AmplOutputComplex</b>, respectively for a parser and output class of complex numbers in AMPL Input format and for a parser and output class of complex numbers in AMPL output format. Finally, these additional parser and output classes should be added in the default parser sets of <a href="doxygen/html/classpelib_1_1_ampl_input.html">AmplInput</a> <a href="doxygen/html/classpelib_1_1_ampl_output.html">AmplOutput</a> defined as static functions that return sets of parser or output classes (or even a pair of both such as <b>AmplInput::intFloatHandlers()</b>).
<li>Adding a new Algebraic text format parser and output requires the addition of an additional class that derives from <a href="doxygen/html/classpelib_1_1_algebra_data_parser.html">AlgebraDataParser</a> in order to create a new branch for parsing this format, and another that derives from <a href="doxygen/html/classpelib_1_1_algebra_data_output.html">AlgebraDataOutput</a>. If this new format can also take different shapes that have the same expressivness power bun in an different syntax, such as AMPL input and AMPL output formats, then it requires another level of inheritance in order to design parsers and output classes for both branches of the same new algebra syntax. They exist for AMPL input and AMPL output as <a href="doxygen/html/classpelib_1_1_ampl_input_data_parser.html">AmplinputDataParser</a> and <a href="doxygen/html/classpelib_1_1_ampl_output_data_parser.html">AmplOutputDataOutput</a>, respectively, added to their output counterpart classes. These four new classes can then be merged into two derivative classes, one for each format branch and each defined as both parser and output classe (look for <a href="doxygen/html/classpelib_1_1_ampl_input_data.html">AmplInputData</a> and <a href="doxygen/html/classpelib_1_1_ampl_output_data.html">AmplOutputData</a>). Finally, these two classes can be derived for each simple data structure parser and output classes. Alternatively, one can design a complex data structure parser and output as described in the second point of this list. It may be faster to implement and to run, but less modular.</li>
<li>A final case consists in the implementation of new, non-algebraic simple data structures. They can be grouped in a complex collection inheriting from pelib::Record. In that case, we need a new base class for these simple data structure, that inherit from pelib::Data just like pelib::AlgebraData, we need base parser and output classes equivalent to pelib::AlgebraDataParser and pelib::AlgebraDataOutput and well as base classes the parsing and output of complex collections, inheriting from pelib::RecordParser and pelib::RecordOutput. Finally we need to apply the procedure described in the previous bullet.</li>
</ul
</p>

<h4 id="parsing_extend">Extend pelib-convert features</h4>
<p>
This section explain how to create plugins to add conversion features to pelib-convert. The plugin takes shape of a dynamic library that can be built using the pelib framework to parse or output data structures. The library needs to implement the C function pelib_parse() (#include &lt;pelib/parser.h&gt;) if must offer a parsing feature and pelib_dump() (#include &lt;pelib/output.h&gt;). Below is the code for a plugin that parses and output Taskgraphs in GraphML text format.
<pre class="brush: cpp">
#include &lt;iostream&gt;

#include &lt;pelib/parser.h&gt;
#include &lt;pelib/output.h&gt;

#include &lt;pelib/GraphML.hpp&gt;

using namespace std;
using namespace pelib;

#ifdef __cplusplus
extern "C" {
#endif

pelib::Record*
pelib_parse(std::istream&amp; cin, size_t argc, char **argv)
{
        return GraphML().parse(cin);
}

void
pelib_delete(Record *obj)
{
	delete obj;
}

void
pelib_dump(std::ostream&amp; cout, std::map&lt;const char*, Record*&gt; records, size_t argc, char **argv)
{
        Taskgraph* tg = (Taskgraph*)records.find(typeid(Taskgraph).name())-&gt;second;
        Platform* pf = (Platform*)records.find(typeid(Platform).name())-&gt;second;

        if(records.find(typeid(Platform).name()) != records.end())
        {
                GraphML().dump(cout, tg, pf);
        }
        else
        {
                GraphML().dump(cout, tg);
        }
}

#ifdef __cplusplus
}
#endif
</pre>
The code is rather short, because all parsers and output are already implemented in the pelib framework. It is highly recommended to implement parser and outputs as part as the pelib framework first and then use it in a pelib-convert plugin. Note that the whole code is surrounded by a the clause "extern "C" {". This is because libdl can only operate on C functions. Therefore, it is mandatory to surround the implementation of pelib_parse(), pelib_delete() and pelib_dump() with this clause.
</p>

<p>pelib_parse() takes an input stream (cin) as well as an array of optional string arguments (argv) and the number of arguments in the array. String arguments can be used to alter the behavior of the parser. They can be used in any manner defined by the plugin programmer, or not used at all. The last element of argv (argv[argc]) is valid and always equals NULL. argv is dynamically allocated and is freed after pelib_parse returns. pelib_parse must return a valid pointer to an instance of a class derived from pelib::Record.
<br>
pelib_delete takes a pointer to a class instance derived from pelib::Record. pelib_delete is always called with an object pelib_parse returned previously. pelib_delete must delete the object instance and free its associated memory.
</p>

<p>pelib_dump() takes an input stream (output), a collection of pointers pelib::Record in a map as well as an array of optional string arguments (argv) and the number of arguments in the array. As for pelib_parse, String arguments can be used to alter the behavior of the output class. They can be used in any manner defined by the plugin programmer, or not used at all. The last element of argv (argv[argc]) is valid and always equals NULL. argv is dynamically allocated and is freed after pelib_dump returns.
<br>
pelib_dump() can find the complex data structure it need to output thanks to a unique class string identifier used as key in the std::map passed as argument (records). For instance, if pelib_dump() requires to output an instance of pelib::taskgraph, it can find it in records with records.find(typeid(pelib::Taskgraph).name()). This can be useful if an output requires more than one instance of pelib::Record to be performed. For instance, pelib::DrakeCSchedule needs and instance of pelib::Schedule, an instance of pelib::Taskgraph and an instance of pelib::Platform to generate some output. Similarly, the example above optionally requires an instance of pelib::Platform to output an instance of pelib::Taskgraph in GraphML format. If your implementation requires more that one instance of the same class derived from pelib::Record, then the class's type name is not enough to find either class instance. In this case, the user can use the pelib-convert switch --name with a predefined string in an input clause (pelib-convert --input ...). pelib_dump() can use this string to find the right object instance in the map collection. 
</p>

<p>
The plugin can be compiled with the line command line below
<pre class="brush: cpp">
g++ -shared -Wl,-soname=libpelib-&lt;structure&gt;-&lt;syntax&gt;.so -o /tmp/libpelib-&lt;structure&gt;-&lt;syntax&gt;.so -fPIC `pkg-config --cflags --libs pelib` plugin.cpp
</pre>
where &lt;structure&gt; is the class name of the data structure parsed and/or output (if both, priority is to the class parsed) and &lt;syntax&gt; is the text format parsed and/or output by the plugin. If the structure is pelib::Algebra, then &lt;structure&gt; should be omitted in the library name. The library must be placed in any directory defined in LD_RUN_PATH at the time pelib-convert was linked ($HOME/.local/lib by default).
</p>
<hr>
<p>
<br>
</p>


<h2 id="ongoing"> Ongoing work </h2>
</a>

<p>
Additional features to be developped include:
<ul>
<li>Parsing and output of XPDL platform descriptions</li>
<li>Generation of graphic representation of schedules</li>
<li>Flexible formula parsing scheme similar to pelib-convert dynamic libraries</li>
</ul>
</p>
<p>
If you would like to contribute, please let us know.
</p>

<hr>
<p>
<br>
</p>

<h2 id="contact">Contact</h2>
</a>

<p>
<ul>
<li><a href="http://www.ida.liu.se/~nicme26">Nicolas Melot</a></li>
<li><a href="http://www.ida.liu.se/~chrke55">Prof. Christoph Kessler</a></li>
</ul>
For reporting bugs, please email to "&lt;firstname&gt; DOT &lt;lastname&gt; AT liu DOT se".
<hr />

<hr>

<h2 id="funding">
Acknowledgments
</h2>
</a>
<p>
This work was partly funded by the EU FP7 project 
<a href="http://www.peppher.eu/">PEPPHER</a> and 
by <a href="http://www.e-science.se">SeRC</a> project OpCoReS.
</p>
<p>
</p>
</font>

<br>

<table width="98%">
<tr bgcolor="#ffffff">
<td border="8"><img width="100" bordercolor="#f0f0f0" src="http://www.par.univie.ac.at/project/peppher/images/EC_logo.jpg">
</td>
<td border="8"><img width="80" bordercolor="#f0f0f0" src="http://www.ida.liu.se/~chrke/logos/fp7.png"></td>

<td border="18"><img width="200" src="https://dcs.cse.chalmers.se/excess/images/excess.png"></td>

<td border="28"><img width="120" src="http://www.e-science.se/sites/default/files/kthc_logo.png"></td>

<td><img width="200" align="right" src="http://www.ida.liu.se/~chrke55/logos/newLiUlogo-en.png">
</td>
</tr>
</table>

</p>


<script type="text/javascript">SyntaxHighlighter.all();</script> 
</body>
</html>
