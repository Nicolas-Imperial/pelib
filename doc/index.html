<html>
<head>
<style type="text/css">
hr.normal { color:#ddd; background-color:#ddd; height:5px; }
hr { color:#000; background-color:#000; height:1px; }
h3 { below-border-color:#000; height:5px; }
pre {
white-space: pre-wrap; /* css-3 */
white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */
white-space: -pre-wrap; /* Opera 4-6 */
white-space: -o-pre-wrap; /* Opera 7 */
word-wrap: break-word; /* Internet Explorer 5.5+ */
}
</style>

<title>
Pelib: Programming Environment Library - Documentation and Examples
</title>

<script type="text/javascript" src="http://www.ida.liu.se/labs/pelab/skepu/syntaxHigh/syntaxhighlighter_3.0.83/scripts/shCore.js"></script> 
<script type="text/javascript" src="http://www.ida.liu.se/labs/pelab/skepu/syntaxHigh/syntaxhighlighter_3.0.83/scripts/shBrushCpp.js"></script> 
<link type="text/css" rel="stylesheet" href="http://www.ida.liu.se/labs/pelab/skepu/syntaxHigh/syntaxhighlighter_3.0.83/styles/shCoreDefault.css"/> 

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37057723-1']);
  _gaq.push(['_setDomainName', 'ida.liu.se']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>

<body bgcolor=#FFFFFF>

<center>
<h1>
<font color=#000000>
Pelib: Programming Environment Library
</font>
</h1>
<h2>
<font color=#000000>
Documentation and Examples
</font>
</h2>
</center>

<p>
</p>

<p>
</p>

<center>
<font face=arial,helvetica size=0 color=#000000>
<table border="1" bordercolor="#101010" bgcolor="#fffff0" cellpadding="3">
<tr>
<td><a href="#overview">Overview</a> </td>
<td><a href="#publications">Publications</a> </td>
<td><a href="#download">Download</a> </td>
<td><a href="#license">License</a> </td>
<td><a href="#ongoing">Ongoing Work</a> </td>
<td><a href="#contact">Contact</a> </td>
<td><a href="#funding">Acknowledgments</a> </td>
</tr>
</table>
</font>
</center>

<p>
</p>

<font face=arial,helvetica size=-1 color=#000000>

<p>
Pelib stands for <b>P</b>rogramming <b>E</b>nvironment <b>Lib</b>rary, as the reference to PELAB (<b>P</b>rogramming <b>E</b>nvironment <b>Lab</b>oratory).
It is a swiss army knife for various research activity, in particular around on-chip pipelining and scheduling research.
The pelib includes a flexible C++ programming interface to read and write simple and complex data structure in various text format such as AMPL input data, AMPL output results, GraphML-based streaming applications models and XML-based schedule descriptions. The capability to parse and generate AMPL input and output data simplifies considerably the automation of experimental performance comparison between Linear Programming solvers and C++ algorithm implementations. A C++ program can generate AMPL input problem instances to feed a linear solver with a AMPL frontend and parse its output to compare with another solving method, such as a C++ implementation of a heuristic. We use this approach in our previous and future <a href="#publications">research papers</a>.
The pelib also provides convenient generic C data structures with type checking, based on an object-oriented design, providing fast ways to show the precise state of internal data structures and functionality composition.
These data structures are extensively used used in the <a href="/labs/pelab/drake/index.html">Drake</a> C stream programming framework.
<br>This pages reviews the main features describes above, how to use and extend them. Section <a href="#overview">overview</a> gives a brief overview of pelib. Section <a href="#download">download</a> provides downloading link to the latest pelib source package. Section <a href="#licence">licence</a> provides information about our publication licence. Section <a href="#publications">publication</a> gives the list of articles we published using this library. Section <a href="#installation">installation</a> provides some explanations to compile and install the library. Section <a href="#parsing">Parsing and generating text representation of complex data structures</a> gives code examples on how to use the parser and output classes provded by pelib and describe the underlying structure to respect when writing new parser and output classes. Section <a href="#c_data_structure">Generic C data structures</a> gives an extended description of the C data structures implemented, how to extend their functionalities as well as adding new generic data structures. Check also the <a href="doxygen/html/index.html">doxygen documentation</a> for more detailed information. Section <a href="#ongoing">Ongoing work</a> details the additional features planned for the future. Section <a href="#contact">Contact</a> gives contact information if you want to contact us. Finally, the page ends with <a href="#funding">Acknowledgments</a>.
</p>

<hr>

<h2 id="overview">Overview</h2>
</a>

<p>
Main features:
<ul>
<li>Parsing and generation of AMPL input data files composed of scalars, vectors, sets or matrices of arbitrary types
<li>Parsing and generation of AMPL output results composed of scalars, vectors, sets or matrices of arbitrary types
<li>Parsing and generation of GraphML-based stream application (taskgraph) descriptions
<li>Parsing and generation of AMPL-based execution platform descriptions
<li>Parsing and generation of streaming application schedules in XML format
<li>Conversion between AMPL input and AMPL output format of algebraic data structures (scalar, vector, set or matrix)
<li>Conversion between GraphML taskgraphs or XML schedules and AMPL input or output data format
<li>API designed for easy maintainability and high extention opportunities
<li>Generic C data structures with type-checking and composability
</ul>

<p>
</p>


<hr>
<p>
<br>
</p>

<h2 id="download">Download</h2>
</a>

<p>
<a href="https://www.ida.liu.se/labs/pelab/pelib/download/pelib-1.0.0.tar.gz" onclick="var that=this;_gaq.push(['_trackEvent','Download','Pelib',this.href]);setTimeout(function(){location.href=that.href;},200);return false;">
<b>Download source code</b></a>
</p>
<p>
<!--
See also the <a href="http://www.ida.liu.se/labs/pelab/pelib/doc_0.8/html/"><b>html documentation</b></a> generated by doxygen.
 -->
</p>
</li>
</ol>

<hr>
<p>
<br>
</p>


<h2 id="license"> Software License </h2>
</a>

<p>
The source code available above is released under GPLv3 licence. Please contact Nicolas Melot (nicolas.melot@liu.se) if you want to obtain another licence.
</p>

<hr>
<p>
<br>
</p>

<h2 id="publications">
Publications 
</h2>
</a>
This library is heavily used internally by Crown scheduling heuristic C++ implementations, C++ schedule analytic evaluators used in our Crown Scheduler paper as well as in the <a href="/labs/pelab/drake/index.html">Drake</a> C stream programming framework. Below is a list of papers whose experimental work relied on the pelib library.
<ul>
<li><p>
Nicolas Melot, Christoph Kessler, Joerg Keller and Patrick Eitschberger
<b>Fast Crown Scheduling Heuristics for Energy-Efficient Mapping and Scaling of Moldable Streaming Tasks on Many-Core Systems.</b>
ACM Transaction on Architecture and Code Optimization, ACM, 2015
</p></li>
<li><p>
Nicolas Melot, Johan Janzen, Christoph Kessler:
<b>Mimer and Schedeval: Comparison Tools for Static Schedulers and Streaming Applications on Concrete Manycore Architectures.</b>
Eighth International Workshop on Parallel Programming Models and Systems Software for High-End Computing (P2S2) at ICPP, 2015. IEEE. 
</p></li>
</ul>


<hr>
<p>
<br>
</p>

<h2 id="installation">Installation</h2>
<p>
Pelib requires the libraries igraph (&gt;= 0.7.1), libdl, libboost-regex, libboost-graph and libexpat, pthread and libxml++-2.6 to compile and run correctly. Once the dependencies are installed, define the environment variables CC=gcc (or any other C compiler you prefer, provided its switches are the same as gcc) and CXX=g++. <a href="download/pelib-1.0.0.tar.gz">Download</a> and extract the pelib source package. cd' into the pelib source directory, make sure you use GNU make and type 
<pre class="brush: cpp">
make install
</pre>
to compile and install the pelib. This will install pelib libraries in $HOME/.local/lib, pelib include files in $HOME/.local/include and pkg-config file in $HOME/.local/lib/pkgconfig. If you wish to install it elsewhere, type
<pre class="brush: cpp">
make install prefix=&lt;/any/path/at/all&gt;
</pre>
Make will create directories bin, lib, lib/pkgconfig and include in the the installation directory you may choose.
</p>

<hr>
<p>
<br>
</p>

<h2 id="parsing">Parsing and generating text representation of complex data structures</h2>
</a>

<p>
This section gives examples on pelib's functionalities to parse complex data structures. Section <a href="#parsing_use">General usage</a> gives example on how to use parser and output classes provided by the pelib. Section <a href="parsing_extend">Contributing</a> gives general indication on how to write your own parser or output class that integrates in pelib.

<h3 id="parsing_use">General usage</h3>
This section gives general usage of the pelib parsing and output framework as well as the conversion command line tool pelib-convert.

<h4 id="parsing_use_framework">Pelib parsing and output framework</h4>
We suppose in this example that we want to load the value of p written in the AMPL input data file "parse-example-1.dat" as follows:
<pre class="brush: cpp">
param p := 3.141592653;
</pre>
The code snippet below uses the AMPL input data parser to reads the input file "example.dat" and outputs the value of scalar "p" to standard output.
<pre class="brush: cpp">
#include &lt;pelib/AmplInput.hpp&gt;

using namespace std;
using namespace pelib;

int
main(int argc, char** argv)
{
	// Variables declaration
        ifstream input; // File input stream
        AmplInput parser(AmplInput::intFloatHandlers()); // AMPL input data parser class with integer and float input parsers and output
        Algebra container; // Collection of Algebraic data structures
        const Scalar&lt;float&gt; *scalar_p; // A scalar
        float p; // Final variable that receives the value parsed

	// Open the file, use AmplInput to parse it into an Algebra container and close the file
        input.open("parse-example-1-data.dat");
        container = parser.parse(input);
        input.close();

	// Find and return the floating-point scalar value named "p" in the algebra container
        scalar_p = container.find&lt;Scalar&lt;float&gt; &gt;("p");

	// Read scalr p's value into float variable p
        p = scalar_p-&gt;getValue();

	// Output p
        cout &lt;&lt; "p = " &tl;&lt; p &lt;&lt; endl;

        return 0;
}
</pre>
You can build this example with the command line
<pre class="brush: cpp">
g++ example-parse-1.cpp `pkg-config --cflags --libs pelib` -o parse-example-1
</pre>
Make sure the file parse-example-1.dat is available in the active directory and contains the text above, then simply type
<pre class="brush: cpp">
./parser-example-1
</pre>
</p>
<p>
Suppose now that we want to generate some AMPL output text format from a array of integers. The code snippet below performs this task:
<pre class="brush: cpp">
#include &lt;pelib/AmplOutput.hpp&gt;
#include &lt;pelib/Vector.hpp&gt;

using namespace std;
using namespace pelib;

int
main(int argc, char** argv)
{
        // Variables declaration
        float F[4] = {1, 2.71, 3.14, 42};
        map&lt;int, float&gt; map_f;

        // Fills a map of values and their keys
        for(size_t i = 0; i &lt; 4; i++)
        {
                map_f.insert(pair&lt;int, float&gt;((int)i + 1, F[i]));
        }

        // Builds a vector named "F" with values in map_f
        Vector&lt;int, float&gt; vector_f("F", map_f);

        // Output vector_f to standard output
        AmplOutput(AmplOutput::intFloatHandlers()).dump(cout, vector_f);

        return 0;
}
</pre>
</p>

<p>
Suppose finally, that we want to convert an AMPL input data file into AMPL output format:
<pre class="brush: cpp">
#include &lt;pelib/AmplInput.hpp&gt;
#include &lt;pelib/AmplOutput.hpp&gt;

using namespace std;
using namespace pelib;

int
main(int argc, char** argv)
{       
        ifstream input;
        Algebra container;
        const Scalar&lt;float&gt; *scalar_p;
        float p;
        
        input.open("example.dat");
        container = AmplInput(AmplInput::intFloatHandlers()).parse(input);
        input.close();

        AmplOutput(AmplOutput::intFloatHandlers()).dump(cout, container);

        return 0;
}
</pre>
</p>

<p>
Parsers and output are also available for more complex data structures, such as streaming application descriptions (taskgraphs) and schedules. Just as Algebraic data structures have Algebra containers, taskgraphs, platform and schedule have their own container classes. Taskgraph and Schedule containers are instanciated by dedicated parsers classes (GraphML and XMLScehdule are available now, respectively for taskgraph and Schedules) and can be output by some output classes (GraphML and XMLSchedule can also output taskgraphs and schedules, respectively) in the exact same manner as shown above. Platform description have no format of its own yet, and is instead read as an algebraic container that is used to instanciate an instance of Platform. Taskgraph, Schedule and Platform classes can all be instanciated from an algebraic description of their respective data structure. Also, they can all build an Algebra container that holds all information about themselves. See the <a href="doxygen/html/index.html">doxygen documentation</a> to get more information about this feature.
</p>

<p>
Here is a list of classes able to parse and output data structures:
<ul>
<li>AmplInput (#include &lt;pelib/AmplInput.hpp&gt;): Parses and output Algebraic data in AMPL input data format
<li>AmplOutput (#include &lt;pelib/AmplOutput.hpp&gt;): Parses and output Algebraic data in AMPL output results format
<li>Cpp (#include &lt;pelib/Cpp.hpp&gt;): Generates C++ code that instanciates pelib algebraic data structures
<li>GraphML (#include &lt;pelib/GraphML.hpp&gt;): Parses and output streaming application high-level descriptions in format based on GraphML
<li>XMLSchedule (#include &lt;pelib/XMLSchedule.hpp&gt;): Parses and output streaming application schedules in XML format
</ul>
</p>

<h4 id="parsing_use_conversion">Pelib conversion tool</h4>

<p>
This section provides a manual to the pelib flexible command line file format conversion tool <b>pelib-convert</b>. pelib-convert can read one or several input stream in any format pelib can parse and output it in any format pelib can output. It uses dynamic libraries to handle input and output streams so that any conversion scenario can be performed without having been explicitely programmed. Here is the syntax of pelib-convert
<pre class="brush: cpp">
pelib-convert (--input ( --format &lt;format&gt; | --lib &lt;library&gt; ) ( --stdin | --file /path/to/input/file ) [ --args &lt;arguments&gt; [ -- ] ] [ --name &lt;name&gt; ] )* (--output ( --format &lt;format&gt; | --lib &lt;library&gt; ) ( --stdout | --stderr | --file /path/to/output/file ) [ --name &lt;name&gt; ] [ --args &lt;arguments&gt; [ -- ] ] )*
</pre>
<b>&lt;format&gt;</b> takes shape as &lt;structure&gt;-&lt;syntax&gt; where &lt;structure&gt; is a complex data structure such as <b>taskgraph</b>, <b>schedule</b> or <b>platform</b> and &lt;syntax&gt; is its text format, such as <b>graphml</b> or <b>xml</b> as well as <b>ampl_input</b> or <b>ampl_output</b>. For algebraic data to parse or output, &lt;structure&gt; must be omitted and &lt;syntax&gt; is one of <b>ampl_input</b> or <b>ampl_output</b>. 
<br><b>&lt;library&gt;</b> denotes the filename of a dynamic library (typically ending with .so) that contains the code to parse or output data in some format. If a path (absolute or relative) is not given, then pelib-convert searches for the library in folders defined by the environment variable LD_RUN_PATH as it was set when pelib-convert was linked, or in LD_LIBRARY_PATH, if defined. "--format &lt;format&gt;" is actually a shortcut for "--lib libpelib-&lt;format&gt;.so"
is any sequence of strings, separated by one or several spaces or tabs. Arguments can be grouped using quote or double quotes or anything your shell provide to pass arguments with space characters. Arguments passed to the parsing or output library stop at the first occurrence of the string "--" or when the last command line argument is read.
<br><b>&lt;arguments&gt;</b> is any sequence of strings, separated by one or several spaces or tabs. Arguments can be grouped using quote or double quotes or anything your shell provide to pass arguments with space characters. Arguments passed to the parsing or output library stop at the first occurrence of the string "--" or when the last command line argument is read. "--" is mandatory if more arguments for pelib-convert follow. libtaskgraph-streamit takes one optional argument to name the taskgraph being parsed. None of the other libraries among ampl_*, taskgraph-*, schedule-* or platform-* require any argument.
<br><b>&lt;name&gt;</b> gives a id to identify an input data source so that several input of the same type (taskgraph, schedule or platform) can be given in a single command line. Some output library may require two instances of the same time. In this case, it needs to differenciate what input serves for a particular purpose. Refer the manual of the output library you use for more information. None of the output libraries ampl_*, taskgraph-*, schedule-* or platform-* require any such name.
</p>

<p>As an example, the command line below is equivalent to the last example given in Section <a href="#parsing_use_framework">pelib parsing and output framework</a>:
<pre class="brush: cpp">
pelib-convert --input --format ampl_input --file example.dat --output --format ampl_output --stdout
</pre>
</p>

<h3 id="parsing_extend">Contributing</h3>
<p>
This section gives insights on the general structure of pelib parsers and output classes so that contributions can preserve its highly flexible feature. Section <a href="#parsing_extend_framework">Extending pelib framework</a> discusses the general structure of the pelib C++ framework and Section <a href="#parsing_extend_convert">Extend pelib-convert features</a> discusses the structure of a pelib-convert parsing and output plugin.
</p>

<h4 id="parsing_extend">Extending pelib framework</h4>
<p>
Every parser and output classes in pelib store or read the data they parse or output in intermediate, format-agnostic data structure classes. These include Algebra, Taskgraph, Platform and Schedule. They serve as an independant pivot point when conversion between formats need to be performed, or as data to feed C++ algorithm implementation with or that C++ algorithm implementations produce. This is a central concept crucial to the flexibility of pelib framework.
<br>Every data structure pelib can handle is a descendant of class pelib::Data or pelib::Record. Descendant classes of pelib::Data represent simple data structures that can be grouped in a collection that derives from pelib::Record. In contrast, pelib::Record classes represent complex data structures. In particular, any algebraic data structure (scalar, vector, set or matrix) derives from pelib::AlgebraData that is itself a descendant of pelib::Data, whereas classes Taskgraph, Platform and Schedule are complex data structures that derive from pelib::Record. All Algebraic data structures (that descend from pelib::AlgebraData) can be included in a algebraic data container (pelib::Algebra) that is considered as a complex data structure and derives from pelib::Record.
</p>
<p>
Parser and an output classes for simple data structures derives from pelib::DataParser and pelib::DataOutput, respectively, or both. More specifically, Algebraic data structure parser and output classes derive from pelib::AlgebraDataParser and pelib::AlgebraDataOutput, respectively, or both. In contrast, parsers and output classes descend from pelib::RecordParser or pelib::RecordOutput, respectively, or both. Again, an algebraic data structure collection parser or output derive from pelib::AlgebraParser or pelib::Algebra parser, that respectively derive from pelib::RecordParser and pelib::RecordOutput. Parser and output classes for Taskgraph, Platform and Schedule also derive from pelib::RecordParser and pelib::RecordOutput (or again, from both). Each simple or complex parser or output class derive from pelib::DataParser or pelib::RecordParser, or their output counterpart, to classes that specialize into different text formats, for instance pelib::GraphMLParser or pelib::AmplInputParser. Finally, parser and output classes specialized for a given format are merged into a single parsing and output class, such as pelib::GraphML or pelib::AmplInput.
</p>
<p>
Parser and output classes of complex data structure composed as several simple data structures (such as pelib::Algebra) are composed of several parsers of simple data structures. For example, pelib::AmplInput parses simple data structure such as pelib::Scalar, pelib::Vector, pelib::Set and pelib::Matrix using pelib::AmplInputScalar (see <a href="doxygen/html/classpelib_1_1_ampl_input_scalar.html">doxygen documentation</a> for a detailed view of its inheritance diagram), pelib::AmplInputVector, pelib::AmplInputSet and pelib::AmplInputMatrix. These classes can also generate outputs in AmplInput formats because they inherit from <a href="doxygen/html/classpelib_1_1_ampl_input_data_output.html">pelib::AmplInputDataOutput</a>. 
</p>
<p>There are several possible scenarii to extend pelib with new parser or output.
<ul>
<li>The implementation of a new parser or output class for a complex data structure that already exists. Such a class needs to inherit from the class that defines a parser or an output class of this complex data structure. For instance, let us call <b>NTGF</b> (for <b>N</b>ew <b>T</b>ask<b>G</b>raph <b>F</b>ormat) a new text format for taskgraphs. In order to implement a new NTGF Taskgraph parser and output, we need to create a class that derives from <a href="doxygen/html/classpelib_1_1_taskgraph_parser.html">pelib::TaskgraphParser</a> and another that derives from <a href="doxygen/html/classpelib_1_1_taskgraph_output.html">TaskgraphOutput</a>. Let us call them <b>NTGFParser</b> and <b>NTGFOutput</b>, respectively. Finally, we can create a new class that combines both the parser and output classes together for convenience. Let us call this final class <b>NTGF</b>.</li>
<li>Implmenting a new complex data structure and its parser and output class. Let us add the complex data structure <b>Car</b>. We need to create a new class <b>Car</b> that derives from the complex data structure ancestor class pelib::Record. Then we need to create classes <b>CarParser</b> and <b>CarOutout</b> so we have common base parser and output classes for any other later parser and output classes for our new complex data structure Car. The we can add the first parsing and output classes using the same procedure as described in the previous bullet</li>
<li>Adding a new simple algebraic data structure beside Scalar or Vector. Let us add the simple data structure for (ironically) complex numbers. We need a new class <b>complex</b> to derive from AlgebraData. We need to implement additional parser and output classes for all syntaxes alread defined for Algebra, that is in the present state of pelib, <a href="doxygen/html/classpelib_1_1_ampl_input_data.html">AmplInputData</a> and <a href="doxygen/html/classpelib_1_1_ampl_output_data.html">AmplOutputData</a>. Let us call these two additional parsing and output classes <b>AmplInputComplex</b> and <b>AmplOutputComplex</b>, respectively for a parser and output class of complex numbers in AMPL Input format and for a parser and output class of complex numbers in AMPL output format. Finally, these additional parser and output classes should be added in the default parser sets of <a href="doxygen/html/classpelib_1_1_ampl_input.html">AmplInput</a> <a href="doxygen/html/classpelib_1_1_ampl_output.html">AmplOutput</a> defined as static functions that return sets of parser or output classes (or even a pair of both such as <b>AmplInput::intFloatHandlers()</b>).
<li>Adding a new Algebraic text format parser and output requires the addition of an additional class that derives from <a href="doxygen/html/classpelib_1_1_algebra_data_parser.html">AlgebraDataParser</a> in order to create a new branch for parsing this format, and another that derives from <a href="doxygen/html/classpelib_1_1_algebra_data_output.html">AlgebraDataOutput</a>. If this new format can also take different shapes that have the same expressivness power bun in an different syntax, such as AMPL input and AMPL output formats, then it requires another level of inheritance in order to design parsers and output classes for both branches of the same new algebra syntax. They exist for AMPL input and AMPL output as <a href="doxygen/html/classpelib_1_1_ampl_input_data_parser.html">AmplinputDataParser</a> and <a href="doxygen/html/classpelib_1_1_ampl_output_data_parser.html">AmplOutputDataOutput</a>, respectively, added to their output counterpart classes. These four new classes can then be merged into two derivative classes, one for each format branch and each defined as both parser and output classe (look for <a href="doxygen/html/classpelib_1_1_ampl_input_data.html">AmplInputData</a> and <a href="doxygen/html/classpelib_1_1_ampl_output_data.html">AmplOutputData</a>). Finally, these two classes can be derived for each simple data structure parser and output classes. Alternatively, one can design a complex data structure parser and output as described in the second point of this list. It may be faster to implement and to run, but less modular.</li>
<li>A final case consists in the implementation of new, non-algebraic simple data structures. They can be grouped in a complex collection inheriting from pelib::Record. In that case, we need a new base class for these simple data structure, that inherit from pelib::Data just like pelib::AlgebraData, we need base parser and output classes equivalent to pelib::AlgebraDataParser and pelib::AlgebraDataOutput and well as base classes the parsing and output of complex collections, inheriting from pelib::RecordParser and pelib::RecordOutput. Finally we need to apply the procedure described in the previous bullet.</li>
</ul
</p>

<h4 id="parsing_extend">Extend pelib-convert features</h4>
<p>
This section explain how to create plugins to add conversion features to pelib-convert. The plugin takes shape of a dynamic library that can be built using the pelib framework to parse or output data structures. The library needs to implement the C function pelib_parse() (#include &lt;pelib/parser.h&gt;) if must offer a parsing feature and pelib_dump() (#include &lt;pelib/output.h&gt;). Below is the code for a plugin that parses and output Taskgraphs in GraphML text format.
<pre class="brush: cpp">
#include &lt;iostream&gt;

#include &lt;pelib/parser.h&gt;
#include &lt;pelib/output.h&gt;

#include &lt;pelib/GraphML.hpp&gt;

using namespace std;
using namespace pelib;

#ifdef __cplusplus
extern "C" {
#endif

pelib::Record*
pelib_parse(std::istream&amp; cin, size_t argc, char **argv)
{
        return GraphML().parse(cin);
}

void
pelib_delete(Record *obj)
{
	delete obj;
}

void
pelib_dump(std::ostream&amp; cout, std::map&lt;const char*, Record*&gt; records, size_t argc, char **argv)
{
        Taskgraph* tg = (Taskgraph*)records.find(typeid(Taskgraph).name())-&gt;second;
        Platform* pf = (Platform*)records.find(typeid(Platform).name())-&gt;second;

        if(records.find(typeid(Platform).name()) != records.end())
        {
                GraphML().dump(cout, tg, pf);
        }
        else
        {
                GraphML().dump(cout, tg);
        }
}

#ifdef __cplusplus
}
#endif
</pre>
The code is rather short, because all parsers and output are already implemented in the pelib framework. It is highly recommended to implement parser and outputs as part as the pelib framework first and then use it in a pelib-convert plugin. Note that the whole code is surrounded by a the clause "extern "C" {". This is because libdl can only operate on C functions. Therefore, it is mandatory to surround the implementation of pelib_parse(), pelib_delete() and pelib_dump() with this clause.
</p>

<p>pelib_parse() takes an input stream (cin) as well as an array of optional string arguments (argv) and the number of arguments in the array. String arguments can be used to alter the behavior of the parser. They can be used in any manner defined by the plugin programmer, or not used at all. The last element of argv (argv[argc]) is valid and always equals NULL. argv is dynamically allocated and is freed after pelib_parse returns. pelib_parse must return a valid pointer to an instance of a class derived from pelib::Record.
<br>
pelib_delete takes a pointer to a class instance derived from pelib::Record. pelib_delete is always called with an object pelib_parse returned previously. pelib_delete must delete the object instance and free its associated memory.
</p>

<p>pelib_dump() takes an input stream (output), a collection of pointers pelib::Record in a map as well as an array of optional string arguments (argv) and the number of arguments in the array. As for pelib_parse, String arguments can be used to alter the behavior of the output class. They can be used in any manner defined by the plugin programmer, or not used at all. The last element of argv (argv[argc]) is valid and always equals NULL. argv is dynamically allocated and is freed after pelib_dump returns.
<br>
pelib_dump() can find the complex data structure it need to output thanks to a unique class string identifier used as key in the std::map passed as argument (records). For instance, if pelib_dump() requires to output an instance of pelib::taskgraph, it can find it in records with records.find(typeid(pelib::Taskgraph).name()). This can be useful if an output requires more than one instance of pelib::Record to be performed. For instance, pelib::DrakeCSchedule needs and instance of pelib::Schedule, an instance of pelib::Taskgraph and an instance of pelib::Platform to generate some output. Similarly, the example above optionally requires an instance of pelib::Platform to output an instance of pelib::Taskgraph in GraphML format. If your implementation requires more that one instance of the same class derived from pelib::Record, then the class's type name is not enough to find either class instance. In this case, the user can use the pelib-convert switch --name with a predefined string in an input clause (pelib-convert --input ...). pelib_dump() can use this string to find the right object instance in the map collection. 
</p>

<p>
The plugin can be compiled with the line command line below
<pre class="brush: cpp">
g++ -shared -Wl,-soname=libpelib-&lt;structure&gt;-&lt;syntax&gt;.so -o /tmp/libpelib-&lt;structure&gt;-&lt;syntax&gt;.so -fPIC `pkg-config --cflags --libs pelib` plugin.cpp
</pre>
where &lt;structure&gt; is the class name of the data structure parsed and/or output (if both, priority is to the class parsed) and &lt;syntax&gt; is the text format parsed and/or output by the plugin. If the structure is pelib::Algebra, then &lt;structure&gt; should be omitted in the library name. The library must be placed in any directory defined in LD_RUN_PATH at the time pelib-convert was linked ($HOME/.local/lib by default).
</p>
<hr>
<p>
<br>
</p>


<h2 id="c_data_structure">Generic C data structures</h2>
<p>
Programming often invlide the use of more or less elaborate data structures. While there are many existing framework that implement efficient data structures, programming for research projects often requires the possibility to understand deeply the internal design of these data structures and the possibility to modify it to fit the project's need. The pelib C data structures are used in research on On-chip pipelining, high-performance parallel computing research project, as in the experiment C streaming framework <a href="/labs/pelab/drake/index.html">Drake</a>. The pelib C data structures are kept as simple as possible, require only a C compile and preprocessor, can be used with any data type while preserving C compilers' type-checking capabilities and follow an object-oriented design that enables code and objects composition. For example, the programmer can define and use basic (integer, float, etc.) and complex (struct { ... }) data types and define pelib object basic operations such as allocation, deallocation, initialization, destruction, or display, to name a few. Also, the programmer can define generic collections of pelib data structures with the same operations as for pelib data types (allocation, etc.) but used in composition of objects it holds.
Composability simplifies the development of data structures for new data types.
Therefore, the implementation of collections of a new data type only requires the definition of the data type as well as its basic pelib operations and the declaration of collections using this data type. 
For instance, one can define a display operation of a basic data type and the display operation of a pelib collection can use it to display its the precise content, showing also the content of objects it contains. This simplifies debugging as it makes it easy to write routines to observe the precise state of any complex data structure.
</p>
<p>
Section <a href="#c_data_structure_basic">Pelib C basics</a> introduces the basic use of pelib data structures, including pelib collections and section <a href="#c_data_structure_extend">Develop new data structures</a> describes how to implement a custom data structure.
</p>

<h3 id="c_data_structure_basic">Pelib C basics</h3>
<p>
Using pelib data structures is very similar to using C++ templates. Let us take the example of integer. The code snippet below declares two pelib integers, initialize and compare them, then increments one integer and compare them both again
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;pelib/integer.h&gt;

int
main(int argc, char **argv)
{
        // Declares a usual integer
        int a, b; 

        // Gives an initial value to this integer, typically 0
        pelib_init(int)(&amp;a);
        pelib_init(int)(&amp;b);

        // Displays both integers
        pelib_printf(int)(stdout, a);
        pelib_printf(int)(stdout, b);

        // Pelib can compare two generic data structures
        int a_lower_than_b = pelib_compare(int)(a, b);
        printf("(C built-in &lt; ) %s\n", a &lt; b ? "A is lower than B" : "A is not lower than B");
        printf("(pelib_compare) %s\n", (a_lower_than_b &lt; 0) ? "A is lower than B" : "A is not lower than B");

        // Now let us modify 3
        b = 1;

        // And let us display both integers again
        pelib_printf(int)(stdout, a);
        pelib_printf(int)(stdout, b);

        // Finally, we can compare both a and b again 
        a_lower_than_b = pelib_compare(int)(a, b);
        printf("(C built-in &lt; ) %s\n", a &lt; b ? "A is lower than B" : "A is not lower than B");
        printf("(pelib_compare) %s\n", (a_lower_than_b &lt; 0) ? "A is lower than B" : "A is not lower than B");

        return EXIT_SUCCESS;
}
</pre>
Compile with:
<pre class="brush: cpp">
gcc test.c -o test `pkg-config --cflags --libs pelib`
</pre>
Note the peculiar function(type)(arguments) function call syntax. This is to compare to C++ template function calls syntax (function&lt;type&gt;(arguments)). Here, we use the pelib functions for an integer. Consult <a href="doxygen/html/structure_8h.html">Doxygen documentation</a> for more information on basic operations for all pelib objects. The code above looks over-complicated. However, it gets more interesting with more complex data structures, such as a complex number. We coded a simple complex number in pelib for the sake of demonstration. In particular, both real and imaginary values are integer and assumed to be greater or equal than 0. Also, we consider that a complex number is higher than another of its real value is higher. If both real parts are equal, then we compare the imaginary part in the same manner.
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;pelib/complex.h&gt;

int
main(int argc, char **argv)
{
        // Declares a usual complex
        complex_t a, b;

        // Gives an initial value to this complex, typically 0
        pelib_init(complex_t)(&amp;a);
        pelib_init(complex_t)(&amp;b);

        // Displays both complexs
        pelib_printf(complex_t)(stdout, a);
        pelib_printf(complex_t)(stdout, b);

        // Pelib can compare two generic data structures
        int a_lower_than_b = pelib_compare(complex_t)(a, b);
        //printf("(C built-in &lt; ) %s\n", a &lt; b ? "A is lower than B" : "A is not lower than B");
        printf("(pelib_compare) %s\n", (a_lower_than_b &lt; 0) ? "A is lower than B" : "A is not lower than B");

        // Now let us modify 3
        b.r = 1;

        // And let us display both complex again
        pelib_printf(complex_t)(stdout, a);
        pelib_printf(complex_t)(stdout, b);

        // Finally, we can compare both a and b again 
        a_lower_than_b = pelib_compare(complex_t)(a, b);
        //printf("(C built-in &lt; ) %s\n", a &lt; b ? "A is lower than B" : "A is not lower than B");
        printf("(pelib_compare) %s\n", (a_lower_than_b &lt; 0) ? "A is lower than B" : "A is not lower than B");

        return EXIT_SUCCESS;
}
</pre>
This code is roughly the same as above; only the type of a and b, as well as the type of calls to generic functions, have changed from int to complex_t. Note that on this example, we cannot use the C built-in comparison operator &lt; anymore, as C doesn't know how to use it with complex numbers. Instead, only pelib_compare can use the right comparison function and compute a meaningful result. 
</p>

<p>
Finally, pelib data types and their function can be composed together. The code below illustrates the use if arrays of integers, arrays of complex and arrays of fifos of complex
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;pelib/integer.h&gt;
#include &lt;pelib/complex.h&gt;

// Create a fifo data structure that handles arrays of complex
// Declare the fifo structure and methods first
#define CFIFO_T array_t(complex_t)
#include &lt;pelib/fifo.h&gt;
// Close the definition of fifo for arrays of complex
#define DONE_cfifo_array_complex_t_t
// Then generate the corresponding code
#define CFIFO_T array_t(complex_t)
#include &lt;pelib/fifo.c&gt;

int
main(int argc, char **argv)
{
        // Iteration variable
        size_t i;

        // Variable declaration and initialization
        int a;
        pelib_init(int)(&amp;a);
        complex_t b;
        pelib_init(complex_t)(&amp;b);

        // Declare and initialize an array of integers, and allocate its buffer
        array_t(int) array_int;
        pelib_init(array_t(int))(&amp;array_int);
        pelib_alloc_buffer(array_t(int))(&amp;array_int, 10);

        // Declare and initialize an array of complex, and allocate its buffer
        array_t(complex_t) array_complex;
        pelib_init(array_t(complex_t))(&amp;array_complex);
        pelib_alloc_buffer(array_t(complex_t))(&amp;array_complex, 10);

        // Fill both integer and complex arrays with increasing number (only in the real value for complex numbers)
        for(i = 0; i &lt; 10; i++)
        {
                pelib_array_append(int)(&amp;array_int, (int)i);
                b.r = (int)i;
                pelib_array_append(complex_t)(&amp;array_complex, b);
        }

        // Display both arrays
        pelib_printf(array_t(int))(stdout, array_int);
        pelib_printf(array_t(complex_t))(stdout, array_complex);

        // Declare and initialize a fifo of arrays of complex, and allocate its buffer
        cfifo_t(array_t(complex_t)) complex_fifo;
        pelib_init(cfifo_t(array_t(complex_t)))(&amp;complex_fifo);
        pelib_alloc_buffer(cfifo_t(array_t(complex_t)))(&amp;complex_fifo, 5);
        // Reinitialize the array of complex (just set its length to 0)
        pelib_init(array_t(complex_t))(&amp;array_complex);

        // Fill the fifo of increasing size arrays sharing the same data buffer
        for(i = 0; i &lt; 3; i++)
        {
                b.r = 10 - (int)i;
                pelib_array_append(complex_t)(&amp;array_complex, b);
		// Below is a bad practice: don't duplicate arrays using a simple copy as it won't copy the array's buffer,
		// but simply copy the pointer to it. It is better to implement pelib_copy() for arrays instead, but
		// we never actually needed it so it's not done yet.
                pelib_cfifo_push(array_t(complex_t))(&amp;complex_fifo, array_complex);
        }

        // Display the composite fifo
        pelib_printf(cfifo_t(array_t(complex_t)))(stdout, complex_fifo);

        return EXIT_SUCCESS;
}
</pre>
The code snippet above illustrate the use of a pelib collection with integers of complex data structures. The declaration of an array of integer consists of the type itself (array_t) as well as a containing type specifier (int) that defines what elements can be stored in the array. Any array method called on this array instance must by typed as int. Basic operation method calls (that applies to the most basic pelib object, such as initialization, see <a href="doxygen/html/structure_8h.html">Doxygen documentation</a>) must be typed as the complete object being manipulated. In line 31 for example, the initialization method is typed as "array_t(int)" as an array of integer is being allocated. More specific methods, such as array's method "append" (line 42) can only be typed with the data type the array handles. This is possible because the method (pelib_array_append) is already specified as an array method in its name.
<br>
The code snippet above generates a new type of fifo able to receive arrays of complex. Line 9 defines a fifo content type (CFIFO) as an array of complex (array_t(complex)) and generates the data structure and method declaration in line 10. After definition, the new type must be marked as done (DONE_*) to avoid multiple definitions. This is done in line 12. Finally the actual method implementations are generated in line 15 by redefining the fifo element type and including the fifo generic code. The remaining of this code example resets the array of complex by calling its initialization method (that just reset its number of elements to 0) and insert in the fifo several copies of increasing size arrays. Note that as array_complex is given as a copy at each call of fifo push, each copy uses the same data buffer, but they record different number of elements inside. This is generally a bad practice; a better approach would be to implement the copy method of an array and reuse it here. However in this example, it provides a simple way to show illustrate the use of composite objects.
</p>

<h3 id="c_data_structure_extend">Develop new data structures</h3>
<p>
Developing new pelib data structure is somewhat challenging, due to the difficulty to read code that makes heavy use of C preprocessor and interpret compilers' outputs. This section gives code snippets that can help to develop new data structures for pelib. Below is a snippet for its header
<pre class="brush: cpp">
// Defines PELIB_CONCAT_2 and PELIB_CONCAT_3 used below
#include &lt;pelib/template.h&gt;
 
// This part is optional, just like any normal header
// Only to declare type-independent stuff related to our structure
#ifndef MYSTRUCT_H
#define MYSTRUCT_H
 
#endif
 
// Here begins the definition of our new data structure
// This line prevents the following block to be imported twice
// for the same type, provided DONE_* is defined after each
// inclusion of this header
#if PELIB_CONCAT_2(DONE_mystruct_, MYSTRUCT) == 0
 
// Declare the name of the new structure and its generic type MYSTRUCT 
// We need to declare two variants: one for the structure itself, another
// for its space-less type alias (see below)
#define mystruct(elem) PELIB_CONCAT_2(mystruct_, elem)
#define mystruct_t(elem) PELIB_CONCAT_2(mystruct(elem), _t)
 
// Declare a frontend name for each function that handle our new structure
#define foo(elem) PELIB_CONCAT_3(tuto_, mystruct_t(elem), _foo)
#define bar(elem) PELIB_CONCAT_3(tuto_, mystruct_t(elem), _bar)
 
// Our actual generic structure
struct mystruct(MYSTRUCT)
{
    int foo;
    MYSTRUCT bar;
};
// A pelib structure cannot have a space in its name
// because of the structure name is used to generate
// function name, therefore we must use a type alias
// using the second type name defined above
typedef struct mystruct(MYSTRUCT) mystruct_t(MYSTRUCT);
 
// This defines the basic object method (allocate, initialize, printf, string, etc.)
// for our new structure
#define STRUCT_T mystruct_t(MYSTRUCT)
#include &lt;pelib/structure.h&gt;
 
// Specific methods for our new structure
// Actual definition of method foo
int foo(MYSTRUCT)(mystruct_t(MYSTRUCT)* obj);
size_t bar(MYSTRUCT)(mystruct_t(MYSTRUCT) obj, size_t n); 
 
// End of definition
#endif
 
// Undefined the generic type name so the portion above cannot be parsed again by error.
#undef MYSTRUCT
</pre>
Note that any copy error in the code above can lead to quite verbose compiler output, very difficult to understand. The code above generates a header with actual C structure and function definitions for each specialized version of our new generic structure. The snippet below gives an actual implementation. We limit it for the purprose of demonstration to the definition of a base method pelib_init and two specialized methods foo and bar. They both use the generic type MYSTRUCT to perform some operations. Just as our structure mystruct, pelib objects are not required to implement all functions defined in pelib/structure.h. However, if your object tries to call a basic method that is unimplemented, the linker will fail to build the final executable. If you want to use a data structure that requires to implement a method you can't implement, then define the missing method, make it to show an error message and abort the program execution, if needed, then avoid to use any method in the data structure you use that may use the missing function.
<pre class="brush: cpp">
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;

#ifndef MYSTRUCT
#error Using generic mystruct without specialization type
#endif

// Basic pelib object mdethods implementations
// Initialization
int
pelib_init(mystruct_t(MYSTRUCT))(mystruct_t(MYSTRUCT)* mystruct)
{
        mystruct-&gt;foo = 56; 
        return pelib_init(MYSTRUCT)(&amp;mystruct-&gt;bar);
}

FILE*
pelib_printf(mystruct_t(MYSTRUCT))(FILE* stream, mystruct_t(MYSTRUCT) mystruct)
{
        fprintf(stream, "%d, ", mystruct.foo);
        pelib_printf(MYSTRUCT)(stream, mystruct.bar);
        return stream;
}

// Many more basic operations should be implemented, but we won't show them for concision
int
foo(MYSTRUCT)(mystruct_t(MYSTRUCT)* obj)
{
        MYSTRUCT ref;

        // By this line we require that any pelib typed used with our structure requires the implementation
        // of basic function init()
        pelib_init(MYSTRUCT)(&amp;ref);

        // Here, we require that the pelib type using our new pelib data structure implements compare()
        return obj-&gt;foo * pelib_compare(MYSTRUCT)(obj-&gt;bar, ref);
}

size_t
bar(MYSTRUCT)(mystruct_t(MYSTRUCT) obj, size_t n)
{
        // Trivial operation, just as an example
        return sizeof(MYSTRUCT) * n;
}
</pre>
The code snippet above should never be compile alone. Instead, it should be included in concrete pelib object implementation. The code below shows the example of an integer making use of our new data structure. As mystruct implements pelib_printf and runs its with the type it is specialized with, we need our integer object to implement some pelib printf method. Let's consider for the sake of example that we can't or don't want to implement it. Instead, we just show an error message.
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "integer.h"

int
pelib_init(int)(int *val)
{
        *val = 0;
        return 1;
}

int
pelib_compare(int)(int a, int b)
{
        return a - b;
}

FILE*
pelib_printf(int)(FILE* stream, int a)
{
        fprintf(stderr, "[%s:%s:%d][ERROR] Not implemented\n", __FILE__, __FUNCTION__, __LINE__);
        return stream;
}

// Generate mystruct functions for integer
#define MYSTRUCT int
#include "mystruct.c"
</pre>
As integer must also be a pelib object, we can have the header below
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define STRUCT_T int
#include &lt;pelib/structure.h&gt;
#define DONE_int

#define MYSTRUCT int
#include "mystruct.h"
#define DONE_mystruct
</pre>
We can fnally use our integer object with mystruct in a program. We declare an instance of mystruct for integers. Because the field bar is generic, it is an int in our example and we can assign it an integer. Then we can use generic forms of methods foo and bar. the pelib basic printf method cannot succeed as our integer doesn't implement it. However as we provided a simple implementation, the program can be compiled and run.
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "integer.h"

#define show_int(var) printf("[%s:%s:%d] %s = %d\n", __FILE__, __FUNCTION__, __LINE__, #var, var)
#define show_size_t(var) printf("[%s:%s:%d] %s = %zu\n", __FILE__, __FUNCTION__, __LINE__, #var, var)

int
main(int argc, char **argv)
{
	// Declare and initialize mystruct for int
        mystruct_t(int) stuff;
        pelib_init(mystruct_t(int))(&amp;stuff);

	// Declare and initialize an integer
        int mybar = 7;

	// We know stuff is a mystruct for int, then we know that stuff.bar is an int and therefore, the line below is correct.
        stuff.bar = mybar;

	// Run the method foo with our mystruct instance and print it value returned on screen
        show_int(foo(int)(&amp;stuff));

	// Same procedure with bar method
        show_size_t(bar(int)(stuff, 42));

	// Finally, let's try the print method.
        pelib_printf(mystruct_t(int))(stdout, stuff);
        return EXIT_SUCCESS;
}
</pre>

</p>

<hr>
<p>
<br>
</p>

<h2 id="ongoing"> Ongoing work </h2>
</a>

<p>
Additional features to be developped include:
<ul>
<li>Adding a hashmap data structure</li>
</ul>
</p>
<p>
If you would like to contribute, please let us know.
</p>

<hr>
<p>
<br>
</p>

<h2 id="contact">Contact</h2>
</a>

<p>
<ul>
<li><a href="http://www.ida.liu.se/~nicme26">Nicolas Melot</a></li>
<li><a href="http://www.ida.liu.se/~chrke55">Prof. Christoph Kessler</a></li>
</ul>
For reporting bugs, please email to "&lt;firstname&gt; DOT &lt;lastname&gt; AT liu DOT se".
<hr />

<hr>

<h2 id="funding">
Acknowledgments
</h2>
</a>
<p>
This work was partly funded by the EU FP7 project 
<a href="http://www.peppher.eu/">PEPPHER</a> and 
by <a href="http://www.e-science.se">SeRC</a> project OpCoReS.
</p>
<p>
</p>
</font>

<br>

<table width="98%">
<tr bgcolor="#ffffff">
<td border="8"><img width="100" bordercolor="#f0f0f0" src="http://www.par.univie.ac.at/project/peppher/images/EC_logo.jpg">
</td>
<td border="8"><img width="80" bordercolor="#f0f0f0" src="http://www.ida.liu.se/~chrke/logos/fp7.png"></td>

<td border="18"><img width="200" src="https://dcs.cse.chalmers.se/excess/images/excess.png"></td>

<td border="28"><img width="120" src="http://www.e-science.se/sites/default/files/kthc_logo.png"></td>

<td><img width="200" align="right" src="http://www.ida.liu.se/~chrke55/logos/newLiUlogo-en.png">
</td>
</tr>
</table>

</p>


<script type="text/javascript">SyntaxHighlighter.all();</script> 
</body>
</html>
